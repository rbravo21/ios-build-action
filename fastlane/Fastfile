default_platform(:ios)

platform :ios do
  desc 'Export ipa'
  lane :export_ipa do
    decode_file
    keychain_password = SecureRandom.uuid
    create_keychain(
      name: 'ios-build.keychain',
      password: keychain_password,
      default_keychain: true,
      unlock: true,
      timeout: 3600
    )
    if @is_split_cer
      import_certificate(
        certificate_path: 'ios-build-key.p12',
        certificate_password: ENV['CERTIFICATE_PASSWORD'],
        keychain_name: 'ios-build.keychain',
        keychain_password: keychain_password,
        log_output: true
      )
      import_certificate(
        certificate_path: 'ios-build-key.cer',
        certificate_password: ENV['CERTIFICATE_PASSWORD'],
        keychain_name: 'ios-build.keychain',
        keychain_password: keychain_password,
        log_output: true
      )
    else
      import_certificate(
        certificate_path: 'ios-build.p12',
        certificate_password: ENV['CERTIFICATE_PASSWORD'],
        keychain_name: 'ios-build.keychain',
        keychain_password: keychain_password,
        log_output: true
      )
    end
    @profiles.each { |profile| install_provisioning_profile(path: profile) }
    if !ENV['UPDATE_TARGETS'].empty?
      update_targets = ENV['UPDATE_TARGETS'].split(/\R/)
    else
      update_targets = ENV['DISABLE_TARGETS'].split(/,/)
    end
    update_code_signing_settings(
      use_automatic_signing: false,
      path: ENV['PROJECT_PATH'],
      targets: update_targets
    )
    if @profiles.length == 1
      update_project_provisioning(
        xcodeproj: ENV['PROJECT_PATH'],
        profile: @profiles[0],
        code_signing_identity: ENV['CODE_SIGNING_IDENTITY'],
        target_filter:
          update_targets.map { |target| "^#{Regexp.escape(target)}$" }.join('|')
      )
    end
    update_project_team(
      path: ENV['PROJECT_PATH'], teamid: ENV['TEAM_ID'], targets: update_targets
    )
    project =
      Xcodeproj::Project.open(
        if Pathname(ENV['PROJECT_PATH']).absolute?
          ENV['PROJECT_PATH']
        else
          "../#{ENV['PROJECT_PATH']}"
        end
      )
    project.targets.each do |target|
      next if !update_targets.empty? && !update_targets.include?(target.name)
      configuration =
        target.build_configurations.find do |bc|
          bc.name == ENV['CONFIGURATION']
        end
      configuration.build_settings['PRODUCT_BUNDLE_IDENTIFIER'] =
        resolve_recursive_build_setting(
          configuration,
          'PRODUCT_BUNDLE_IDENTIFIER'
        )
    end
    project.save
    build_app(
      workspace: !ENV['WORKSPACE_PATH'].empty? ? ENV['WORKSPACE_PATH'] : nil,
      project: ENV['WORKSPACE_PATH'].empty? ? ENV['PROJECT_PATH'] : nil,
      configuration: ENV['CONFIGURATION'],
      scheme: ENV['SCHEME'],
      output_directory: File.dirname(ENV['OUTPUT_PATH']),
      output_name: File.basename(ENV['OUTPUT_PATH']),
      clean: true,
      export_method: ENV['EXPORT_METHOD'],
      export_options:
        !ENV['EXPORT_OPTIONS'].empty? ? ENV['EXPORT_OPTIONS'] : nil
    )
    delete_keychain(name: 'ios-build.keychain')
  end

  # https://github.com/CocoaPods/Xcodeproj/issues/505#issuecomment-584699008
  # Augments config.resolve_build_setting from xcproject
  # to continue expanding build settings and evaluate modifiers
  def resolve_recursive_build_setting(config, setting)
    resolution = config.resolve_build_setting(setting)

    # finds values with one of
    # $VALUE
    # $(VALLUE)
    # $(VALUE:modifier)
    # ${VALUE}
    # ${VALUE:modifier}
    resolution&.gsub(/\$[\(\{]?.+[\)\}]?/) do |raw_value|
      # strip $() characters
      unresolved =
        raw_value.gsub(/[\$\(\)\{\}]/, '')

      # Get the modifiers after the ':' characters
      name, *modifiers = unresolved.split(':')

      # Expand variable name
      subresolution = resolve_recursive_build_setting(config, name)

      # Apply modifiers
      # NOTE: not all cases accounted for
      #
      # See http://codeworkshop.net/posts/xcode-build-setting-transformations
      # for various modifier options
      modifiers.each do |modifier|
        case modifier
        when 'lower'
          subresolution.downcase!
        when 'upper'
          subresolution.upcase!
        else
          # Fastlane message
          UI.error("Unknown modifier: `#{modifier}` in `#{raw_value}")
        end
      end

      subresolution
    end
  end

  def decode_file
    @is_split_cer =
      !ENV['P12_KEY_BASE64'].empty? && !ENV['P12_CER_BASE64'].empty?
    if @is_split_cer
      File.write('../ios-build-key.p12', Base64.decode64(ENV['P12_KEY_BASE64']))
      File.write('../ios-build-key.cer', Base64.decode64(ENV['P12_CER_BASE64']))
    else
      File.write('../ios-build.p12', Base64.decode64(ENV['P12_BASE64']))
    end
    @profiles = []
    ENV['MOBILEPROVISION_BASE64'].split(/\R/).each.with_index(
      1
    ) do |profile, index|
      filename = "ios-build-#{index}.mobileprovision"
      File.write("../#{filename}", Base64.decode64(profile))
      @profiles.push(filename)
    end
  end
end
